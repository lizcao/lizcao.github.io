<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术博客</title>
    <link>https://lizcao.github.io/</link>
    <description>Recent content on 技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>lizcao copyright.</copyright>
    <lastBuildDate>Sun, 24 May 2020 00:37:10 +0800</lastBuildDate>
    
        <atom:link href="https://lizcao.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>TCP三次握手和四次挥手</title>
        <link>https://lizcao.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
        <pubDate>Sun, 24 May 2020 00:37:10 +0800</pubDate>
        
        <guid>https://lizcao.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
        <description>技术博客 https://lizcao.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/ -&lt;blockquote&gt;
&lt;p&gt;人，只要有一种信念，有所追求，什么艰苦都能忍受，什么环境也都能适应。——丁玲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;三次握手流程图&#34;&gt;三次握手流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/1002211-20191130222422452-127219771.png&#34; alt=&#34;1002211-20191130222422452-127219771&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;四次挥手流程图&#34;&gt;四次挥手流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/u=958516549,2180335224&amp;amp;fm=26&amp;amp;gp=0.jpg&#34; alt=&#34;u=958516549,2180335224&amp;fm=26&amp;gp=0&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;tcp报文&#34;&gt;tcp报文&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/2.png&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中，Seq(Sequence Number) 是 32 位的序列号，&lt;code&gt;Acknowledgment number&lt;/code&gt; 称之为确认序号，也是 32 位的，但是他不是标志位 ACK，这个要区别开，当 ACK 置 1 时 &lt;code&gt;Acknowledgment number&lt;/code&gt; 才有效，指接收方期待的下一个报文段的序列号。&lt;/p&gt;
&lt;p&gt;TCP 报头信息中有六个控制位(标志位)，分别是：SYN、ACK、PSH、FIN、RST 和 URG。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYN: 表示建立连接
FIN: 表示关闭连接
ACK: 表示响应
PSH: 表示有数据传输
RST: 表示连接重置
URG: 表示紧急数据
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seq 序列号有两个作用：
第一，在 SYN 置 1 时，此为当前连接的初始序列号(Initial Sequence Number, ISN)该值是个随机值，数据的第一个字节序号为此 ISN+1。&lt;/p&gt;
&lt;p&gt;第二，在 SYN 置 0 时，为当前连接报文段的累计数据包字节数。&lt;/p&gt;
&lt;h2 id=&#34;网络模型&#34;&gt;网络模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/1629935-20190412155007282-2076867106.png&#34; alt=&#34;1629935-20190412155007282-2076867106&#34;&gt;&lt;/p&gt;
&lt;p&gt;计算机网络分层模型主要有OSI七层模型，TCP/IP五层模型，也有一种四层模型，四层模型会把网卡层和物理层统称为网络接口层。&lt;/p&gt;
&lt;p&gt;OSI七层模型存在于教科书了，TCP/IP五层模型是日常运用最为广泛的一种网络架构模型。在学习网络知识时也要把握住重点去学，七层模型了解即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/130957m7v2xta7kzft2d7v.jpg&#34; alt=&#34;130957m7v2xta7kzft2d7v&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;代码准备&#34;&gt;代码准备&lt;/h2&gt;
&lt;p&gt;server.php&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//创建Server对象，监听 127.0.0.1:9501端口
$serv = new Swoole\Server(&amp;quot;127.0.0.1&amp;quot;, 9501);

//监听连接进入事件
$serv-&amp;gt;on(&#39;Connect&#39;, function ($serv, $fd) {
    echo &amp;quot;Client: Connect.\n&amp;quot;;
});

//监听数据接收事件
$serv-&amp;gt;on(&#39;Receive&#39;, function ($serv, $fd, $from_id, $data) {
    $serv-&amp;gt;send($fd, &amp;quot;Server: &amp;quot;.$data);
});

//监听连接关闭事件
$serv-&amp;gt;on(&#39;Close&#39;, function ($serv, $fd) {
    echo &amp;quot;Client: Close.\n&amp;quot;;
});

//启动服务器
$serv-&amp;gt;start();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;client.php&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//client.php
$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);
$client-&amp;gt;connect(&#39;127.0.0.1&#39;, 9501) || exit(&amp;quot;connect failed. Error: {$client-&amp;gt;errCode}\n&amp;quot;);

// 向服务端发送数据
$client-&amp;gt;send(&amp;quot;Just a test.\r\n&amp;quot;);
$client-&amp;gt;close();
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;wireshark准备&#34;&gt;wireshark准备&lt;/h2&gt;
&lt;p&gt;抓包网络选择lookback&lt;/p&gt;
&lt;p&gt;筛选条件输入ip.addr == 127.0.0.1 and  tcp.port in {9501}&lt;/p&gt;
&lt;h2 id=&#34;tcp请求&#34;&gt;Tcp请求&lt;/h2&gt;
&lt;p&gt;直接请求client.php&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;php  client.php
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;抓包&#34;&gt;抓包&lt;/h2&gt;
&lt;h2 id=&#34;模型分析&#34;&gt;模型分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523184857040.png&#34; alt=&#34;image-20200523184857040&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面模型网络里有五层，这里只有四层，是因为我直接请求的tcp，没有走应用层，所以只有四层。&lt;/p&gt;
&lt;h2 id=&#34;三次握手抓包分析&#34;&gt;三次握手抓包分析&lt;/h2&gt;
&lt;p&gt;看到wireshark已经抓到了请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523180836466.png&#34; alt=&#34;image-20200523180836466&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第一次握手&#34;&gt;第一次握手&lt;/h5&gt;
&lt;p&gt;客户端向服务器发送连接请求包，标志位SYN=1，序列号Seq=0（为方便下面的计算用这里的Seq起名为X），如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523182423880.png&#34; alt=&#34;image-20200523182423880&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/132355zqm2skuwm8q2yuzg.jpg&#34; alt=&#34;132355zqm2skuwm8q2yuzg&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第二次握手&#34;&gt;第二次握手&lt;/h5&gt;
&lt;p&gt;服务器收到客户端发过来报文，由SYN=1知道客户端要求建立联机。向客户端发送一个SYN和ACK都为1的TCP报文，设置初始序号Seq=0（为方便下面的计算用这里的Seq起名为Y），将确认序号(Acknowledgement Number)设置为客户的序列号加1，即X+1=0+1=1，所以这里的序列号为1, 如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523182738543.png&#34; alt=&#34;image-20200523182738543&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/132450t4spsguuwlaemez5.jpg&#34; alt=&#34;132450t4spsguuwlaemez5&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第三次握手&#34;&gt;第三次握手&lt;/h5&gt;
&lt;p&gt;客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次发送的序号加1（X+1=1）。以及标志位ACK是否为1。若正确，客户端再次发送确认包，ACK标志位为1，SYN标志位为0。确认序号(Acknowledgement Number)=Y+1=0+1=1，发送序号为X+1=1。服务端收到后确认序号值与ACK=1则连接建立成功，可以传送数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523183640836.png&#34; alt=&#34;image-20200523183640836&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/132538pqssss4ceszes4sx.jpg&#34; alt=&#34;132538pqssss4ceszes4sx&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;四次挥手抓包分析&#34;&gt;四次挥手抓包分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523220651612.png&#34; alt=&#34;image-20200523220651612&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第一次挥手&#34;&gt;第一次挥手&lt;/h5&gt;
&lt;p&gt;客户端给服务器发送TCP包，用来关闭客户端到服务器的数据传送。将标志位FIN和ACK置为1，序号为X=15，确认序号为Z=1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523221619960.png&#34; alt=&#34;image-20200523221619960&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/132803xomlsmpbzmrioibb.jpg&#34; alt=&#34;132803xomlsmpbzmrioibb&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第二次挥手&#34;&gt;第二次挥手&lt;/h5&gt;
&lt;p&gt;服务器收到FIN后，发回一个ACK(标志位ACK=1),确认序号为收到的序号加1，即X=X+1=16。序号为收到的确认序号=Z。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523221933721.png&#34; alt=&#34;image-20200523221933721&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/132951z9uzba8ind90n8ai.jpg&#34; alt=&#34;132951z9uzba8ind90n8ai&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第三次挥手&#34;&gt;第三次挥手&lt;/h5&gt;
&lt;p&gt;服务器关闭与客户端的连接，发送一个FIN。标志位FIN和ACK置为1，序号为Y=1，确认序号为X=16。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523222145938.png&#34; alt=&#34;image-20200523222145938&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/133044hlr71pqqqurr7pzc.jpg&#34; alt=&#34;133044hlr71pqqqurr7pzc&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;第四次握手&#34;&gt;第四次握手&lt;/h5&gt;
&lt;p&gt;客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认序号为收到的序号加1，即Y+1=2。序号为收到的确认序号X=16。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200523222333500.png&#34; alt=&#34;image-20200523222333500&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/133145oqqlxqgxoaz1g13w.jpg&#34; alt=&#34;133145oqqlxqgxoaz1g13w&#34;&gt;&lt;/p&gt;
- https://lizcao.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/ - lizcao copyright.</description>
        </item>
    
    
    
        <item>
        <title>TCP粘包问题正解</title>
        <link>https://lizcao.github.io/posts/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%AD%A3%E8%A7%A3/</link>
        <pubDate>Sun, 24 May 2020 00:37:10 +0800</pubDate>
        
        <guid>https://lizcao.github.io/posts/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%AD%A3%E8%A7%A3/</guid>
        <description>技术博客 https://lizcao.github.io/posts/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%AD%A3%E8%A7%A3/ -&lt;blockquote&gt;
&lt;p&gt;自知之明是最难得的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp传输的特点&#34;&gt;TCP传输的特点&lt;/h2&gt;
&lt;p&gt;TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;
&lt;h3 id=&#34;面向连接&#34;&gt;面向连接&lt;/h3&gt;
&lt;p&gt;面向连接意味着使用tcp的应用程序在传输数据前必须先建立连接，三次握手&lt;/p&gt;
&lt;h3 id=&#34;基于字节流的传输&#34;&gt;基于字节流的传输&lt;/h3&gt;
&lt;p&gt;发送端执行的写操作数和接收端执行的读操作次数之间没有任何数量关系，当发送端应用程序连续执行多次写操作的时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据的时候，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出&lt;/p&gt;
&lt;h3 id=&#34;可靠&#34;&gt;可靠&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功。&lt;/li&gt;
&lt;li&gt;TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么是tcp粘包问题&#34;&gt;什么是TCP粘包问题&lt;/h2&gt;
&lt;p&gt;TCP粘包是一个错误的说法，TCP是流式传输，没有包的概念，更没有粘包一说。&lt;/p&gt;
&lt;p&gt;人们常说的粘包问题，是指发送方应该以什么格式发送数据，接收方能正确解析出数据，这个叫应用层协议，你自己定，跟TCP完全无关。如果是发文件，最简单的你可以用http协议封装，如果你发的http协议数据是100%正确的，无论哪个接收方（nginx/tomcat/iis）保证能一字节不差地收下，因为http协议本身就带header和body，header里有Content-Length: 12345指定了body的大小，body才是文件本身。&lt;/p&gt;
&lt;p&gt;你不用http协议，直接发文件数据，那么问题来了，接收方怎么知道应该收多少字节后文件结束？这个才是真正粘包问题的由来。&lt;/p&gt;
&lt;p&gt;所有TCP粘包问题就转化成了如何界定TCP流式传输边界的问题。&lt;/p&gt;
&lt;h2 id=&#34;tcp粘包的原因&#34;&gt;TCP粘包的原因&lt;/h2&gt;
&lt;h3 id=&#34;缓冲区&#34;&gt;缓冲区&lt;/h3&gt;
&lt;p&gt;通常我们直觉性的认为，客户端直接向网络中传输数据，对端从网络中读取数据，但是这是不正确的。&lt;/p&gt;
&lt;p&gt;socket有缓冲区buffer的概念，每个TCP socket在内核中都有一个发送缓冲区和一个接收缓冲区。客户端send操作仅仅是把数据拷贝到buffer中，也就是说send完成了，数据并不代表已经发送到服务端了，之后才由TCP协议从buffer中发送到服务端。此时服务端的接收缓冲区被TCP缓存网络上来的数据，而后server才从buffer中读取数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当连续发送数据时，由于tcp协议的nagle算法，会将较小的内容拼接成大的内容，一次性发送到服务器端，因此造成粘包
当发送内容较大时，由于服务器端的recv（buffer_size）方法中的buffer_size较小，不能一次性完全接收全部内容，因此在下一次请求到达时，接收的内容依然是上一次没有完全接收完的内容，因此造成粘包现象。
接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/1503450-20200318205534350-396366488.png&#34; alt=&#34;1503450-20200318205534350-396366488&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;粘包拆包表现形式&#34;&gt;粘包、拆包表现形式&lt;/h3&gt;
&lt;p&gt;第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。&lt;/p&gt;
&lt;p&gt;第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。&lt;/p&gt;
&lt;p&gt;第三种情况，这种情况有两种表现形式。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。&lt;/p&gt;
&lt;h2 id=&#34;tcp粘包的解决方法&#34;&gt;TCP粘包的解决方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;EOF 结束符协议&lt;/li&gt;
&lt;li&gt;固定包头 + 包体协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;粘包复现&#34;&gt;粘包复现&lt;/h2&gt;
&lt;p&gt;创建一个server，server端代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

class TcpBufferServer
{
    private $_serv;

    /**
     * init
     */
    public function __construct()
    {
        $this-&amp;gt;_serv = new Swoole\Server(&amp;quot;127.0.0.1&amp;quot;, 9501);
        $this-&amp;gt;_serv-&amp;gt;set([
            &#39;worker_num&#39; =&amp;gt; 1,
        ]);
        $this-&amp;gt;_serv-&amp;gt;on(&#39;Receive&#39;, [$this, &#39;onReceive&#39;]);
    }
    public function onReceive($serv, $fd, $fromId, $data)
    {
        echo &amp;quot;Server received data: {$data}&amp;quot; . PHP_EOL;
    }
    /**
     * start server
     */
    public function start()
    {
        $this-&amp;gt;_serv-&amp;gt;start();
    }
}

$reload = new TcpBufferServer;
$reload-&amp;gt;start();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;server的代码很简单，仅仅是在收到客户端代码后，标准输出一句话而已，client的代码需要注意了，我们写了一个for循环，连续向server send三条信息，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);
$client-&amp;gt;connect(&#39;127.0.0.1&#39;, 9501) || exit(&amp;quot;connect failed. Error: {$client-&amp;gt;errCode}\n&amp;quot;);

// 向服务端发送数据
for ($i = 0; $i &amp;lt; 3; $i++) {
    $client-&amp;gt;send(&amp;quot;Just a test.\n&amp;quot;);
}
$client-&amp;gt;close();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在未运行测试的情况下，我们期望server所在终端输出的结果应该是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Server received data: Just a test.
Server received data: Just a test.
Server received data: Just a test.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意哦，我们期望的结果是server被回调了3次，才有上述期望的结果值&lt;/p&gt;
&lt;p&gt;实际运行的结果呢，是否与我们所期望的一致？我们看下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/c484586336-tcp-buffer-1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图左边是server输出的信息。&lt;/p&gt;
&lt;p&gt;我们看到，左侧显示的结果是server一次性输出的结果，按理论来说，client发起了3次请求，server应该跟我们期望的结果一致，会执行3次呀，但是事实并不是，这就产生了粘包，看下抓包的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200524160856253.png&#34; alt=&#34;image-20200524160856253&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/image-20200524161040797.png&#34; alt=&#34;image-20200524161040797&#34;&gt;&lt;/p&gt;
&lt;p&gt;由抓包的图可见，三次请求的内容到了缓冲区后，作为两次发送，有两个数据发生了粘包，到了服务端缓冲区后，是三个一起取出产生了粘包。&lt;/p&gt;
&lt;h2 id=&#34;eof结束协议&#34;&gt;EOF结束协议&lt;/h2&gt;
&lt;p&gt;EOF，end of file，意思是我们在每一个数据包的结尾加一个eof标记，表示这就是一个完整的数据包，但是如果你的数据本身含有EOF标记，那就会造成收到的数据包不完整，所以开启EOF支持后，应避免数据中含有EOF标记。&lt;/p&gt;
&lt;p&gt;在swoole_server中，我们可以配置open_eof_check为true，打开EOF检测，配置package_eof来指定EOF标记。&lt;/p&gt;
&lt;p&gt;swoole_server收到一个数据包时，会检测数据包的结尾是否是我们设置的EOF标记，如果不是就会一直拼接数据包，直到超出buffer或者超时才会终止，一旦认定是一个完整的数据包，就会投递给Worker进程，这时候我们才可以在回调内处理数据。&lt;/p&gt;
&lt;p&gt;这样server就能保证接收到一个完整的数据包了？不能保证，这样只能保证server能收到一个或者多个完整的数据包。&lt;/p&gt;
&lt;p&gt;为啥是多个呢？&lt;/p&gt;
&lt;p&gt;我们说了开启EOF检测，即open_eof_check设置为true，server只会检测数据包的末尾是否有EOF标记，如果向我们开篇的案例连发3个EOF的数据，server可能还是会一次性收到，这样我们只能在回调内对数据包进行拆分处理。&lt;/p&gt;
&lt;p&gt;我们拿开篇的案例为例&lt;/p&gt;
&lt;p&gt;server开启eof检测并指定eof标记是\r\n，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

class TcpBufferServer
{
    private $_serv;

    /**
     * init
     */
    public function __construct()
    {
        $this-&amp;gt;_serv = new Swoole\Server(&amp;quot;127.0.0.1&amp;quot;, 9501);
       /* $this-&amp;gt;_serv-&amp;gt;set([
            &#39;worker_num&#39; =&amp;gt; 1,
        ]);*/
        $this-&amp;gt;_serv-&amp;gt;set([
            &#39;worker_num&#39; =&amp;gt; 1,
            &#39;open_eof_check&#39; =&amp;gt; true, //打开EOF检测
            &#39;package_eof&#39; =&amp;gt; &amp;quot;\r\n&amp;quot;, //设置EOF
        ]);

        $this-&amp;gt;_serv-&amp;gt;on(&#39;Receive&#39;, [$this, &#39;onReceive&#39;]);
    }
    public function onReceive($serv, $fd, $fromId, $data)
    {
        echo &amp;quot;Server received data: {$data}&amp;quot; . PHP_EOL;
    }
    /**
     * start server
     */
    public function start()
    {
        $this-&amp;gt;_serv-&amp;gt;start();
    }
}

$reload = new TcpBufferServer;
$reload-&amp;gt;start();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端设置发送的数据末尾是\r\n符号，代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);
$client-&amp;gt;connect(&#39;127.0.0.1&#39;, 9501) || exit(&amp;quot;connect failed. Error: {$client-&amp;gt;errCode}\n&amp;quot;);

// 向服务端发送数据
/*for ($i = 0; $i &amp;lt; 3; $i++) {
    $client-&amp;gt;send(&amp;quot;Just a test.\n&amp;quot;);
}*/

for ($i = 0; $i &amp;lt; 3; $i++) {
    $client-&amp;gt;send(&amp;quot;Just a test.\r\n&amp;quot;);
}

$client-&amp;gt;close();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照我们刚才的分析，server的效果可能会一次性收到多个完整的包，我们运行看看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/845ca5d229-server-eof-check.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;明显不是我们想要的结果，抓包的结果与上面是一样的。&lt;/p&gt;
&lt;p&gt;原来我们还需要在onReceive回调内对收到的数据进行拆分处理&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;public function onReceive($serv, $fd, $fromId, $data)
{
    // echo &amp;#34;Server received data: {$data}&amp;#34; . PHP_EOL;

    $datas = explode(&amp;#34;\r\n&amp;#34;, $data);
    foreach ($datas as $data)
    {
        if(!$data)
            continue;

        echo &amp;#34;Server received data: {$data}&amp;#34; . PHP_EOL;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时我们再看下运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/6ff4cf8e12-server-eof-check-2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;自行分包的效果便实现了，考虑到自行分包稍微麻烦，swoole提供了open_eof_split配置参数，启用该参数后，server会从左到右对数据进行逐字节对比，查找数据中的EOF标记进行分包，效果跟我们刚刚自行拆包是一样的，性能较差。&lt;/p&gt;
&lt;p&gt;在案例的基础上我们看看open_eof_split配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;$this-&amp;gt;_serv-&amp;gt;set([
    &amp;#39;worker_num&amp;#39; =&amp;gt; 1,
    &amp;#39;open_eof_check&amp;#39; =&amp;gt; true, //打开EOF检测
    &amp;#39;package_eof&amp;#39; =&amp;gt; &amp;#34;\r\n&amp;#34;, //设置EOF
    &amp;#39;open_eof_split&amp;#39; =&amp;gt; true,
]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;onReceive的回调，我们不需要自行拆包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;public function onReceive($serv, $fd, $fromId, $data)
{
     echo &amp;#34;Server received data: {$data}&amp;#34; . PHP_EOL;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;client的测试代码使用\r\n（同server端package_eof标记一致），我们看下运行效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/af126fe46e-server-eof-split.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;EOF标记解决粘包就说这么多，下面我们再看看另一种解决方案&lt;/p&gt;
&lt;h2 id=&#34;固定包头包体协议&#34;&gt;固定包头+包体协议&lt;/h2&gt;
&lt;p&gt;固定包头是一种非常通用的协议，它的含义就是在你要发送的数据包的前面，添加一段信息，这段信息了包含了你要发送的数据包的长度，长度一般是2个或者4个字节的整数。&lt;/p&gt;
&lt;p&gt;在这种协议下，我们的数据包的组成就是包头+包体。其中包头就是包体长度的二进制形式。比如我们本来想向服务端发送一段数据 &amp;ldquo;Just a test.&amp;rdquo; 共12个字符，现在我们要发送的数据就应该是这样的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;pack(&amp;#39;N&amp;#39;, strlen(&amp;#34;Just a test.&amp;#34;)) . &amp;#34;Just a test.&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中php的pack函数是把数据打包成二进制字符串。&lt;/p&gt;
&lt;p&gt;为什么这样就能保证Worker进程收到的是一个完整的数据包呢？我来解释一下：&lt;/p&gt;
&lt;p&gt;当server收到一个数据包（可能是多个完整的数据包）之后，会先解出包头指定的数据长度，然后按照这个长度取出后面的数据，如果一次性收到多个数据包，依次循环，如此就能保证Worker进程可以一次性收到一个完整的数据包。&lt;/p&gt;
&lt;p&gt;我们以案例来分析&lt;/p&gt;
&lt;p&gt;server代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;?php&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ServerPack&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;$_serv&lt;/span&gt;;

    &lt;span style=&#34;color:#cd5555&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;     * init
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; __construct()
    {
        &lt;span style=&#34;color:#00688b&#34;&gt;$this&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;_serv&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Swoole\Server(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;127.0.0.1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;9501&lt;/span&gt;);
        &lt;span style=&#34;color:#00688b&#34;&gt;$this&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;_serv&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt;([
            &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;worker_num&amp;#39;&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,
            &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;open_length_check&amp;#39;&lt;/span&gt;     =&amp;gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;,      &lt;span style=&#34;color:#228b22&#34;&gt;// 开启协议解析
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;package_length_type&amp;#39;&lt;/span&gt;   =&amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;,     &lt;span style=&#34;color:#228b22&#34;&gt;// 长度字段的类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;package_length_offset&amp;#39;&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,       &lt;span style=&#34;color:#228b22&#34;&gt;//第几个字节是包长度的值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;package_body_offset&amp;#39;&lt;/span&gt;   =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,       &lt;span style=&#34;color:#228b22&#34;&gt;//第几个字节开始计算长度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;package_max_length&amp;#39;&lt;/span&gt;    =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;81920&lt;/span&gt;,  &lt;span style=&#34;color:#228b22&#34;&gt;//协议最大长度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        ]);
        &lt;span style=&#34;color:#00688b&#34;&gt;$this&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;_serv&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Receive&amp;#39;&lt;/span&gt;, [&lt;span style=&#34;color:#00688b&#34;&gt;$this&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;onReceive&amp;#39;&lt;/span&gt;]);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onReceive&lt;/span&gt;(&lt;span style=&#34;color:#00688b&#34;&gt;$serv&lt;/span&gt;, &lt;span style=&#34;color:#00688b&#34;&gt;$fd&lt;/span&gt;, &lt;span style=&#34;color:#00688b&#34;&gt;$fromId&lt;/span&gt;, &lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#00688b&#34;&gt;$info&lt;/span&gt; = unpack(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt;);
        &lt;span style=&#34;color:#00688b&#34;&gt;$len&lt;/span&gt; = &lt;span style=&#34;color:#00688b&#34;&gt;$info&lt;/span&gt;[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
        &lt;span style=&#34;color:#00688b&#34;&gt;$body&lt;/span&gt; = substr(&lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt;, - &lt;span style=&#34;color:#00688b&#34;&gt;$len&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;server received data: &lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;{&lt;/span&gt;$body&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#cd5555&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;     * start server
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;start&lt;/span&gt;()
    {
        &lt;span style=&#34;color:#00688b&#34;&gt;$this&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;_serv&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;start&lt;/span&gt;();
    }
}

&lt;span style=&#34;color:#00688b&#34;&gt;$reload&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ServerPack;
&lt;span style=&#34;color:#00688b&#34;&gt;$reload&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;start&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;客户端的代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;?php&lt;/span&gt;

&lt;span style=&#34;color:#00688b&#34;&gt;$client&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);
&lt;span style=&#34;color:#00688b&#34;&gt;$client&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;connect&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;9501&lt;/span&gt;) || &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;connect failed. Error: &lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;{&lt;/span&gt;$client-&amp;gt;errCode&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;);

&lt;span style=&#34;color:#228b22&#34;&gt;// 向服务端发送数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b&#34;&gt;$i&lt;/span&gt; = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#00688b&#34;&gt;$i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;; &lt;span style=&#34;color:#00688b&#34;&gt;$i&lt;/span&gt;++) {
    &lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Just a test.&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt; = pack(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, strlen(&lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt;)) . &lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b&#34;&gt;$client&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#00688b&#34;&gt;$data&lt;/span&gt;);
}

&lt;span style=&#34;color:#00688b&#34;&gt;$client&lt;/span&gt;-&amp;gt;&lt;span style=&#34;color:#658b00&#34;&gt;close&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lizcao.github.io/images/4f422b928f-server-pack.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;结果没错，是我们期望的结果。&lt;/p&gt;
&lt;p&gt;我们来分析下这是为什么&lt;/p&gt;
&lt;p&gt;1、首先，在server端我们配置了open_length_check，该参数表明我们要开启固定包头协议解析&lt;/p&gt;
&lt;p&gt;2、package_length_type配置，表明包头长度的类型，这个类型跟客户端使用pack打包包头的类型一致，一般设置为N或者n，N表示4个字节，n表示2个字节&lt;/p&gt;
&lt;p&gt;3、我们看下客户端的代码 pack(&amp;lsquo;N&amp;rsquo;, strlen($data)) . 𝑑𝑎𝑡𝑎，这句话就是包头+包体的意思，包头是𝑝𝑎𝑐𝑘函数打包的二进制数据，内容便是真实数据的长度𝑠𝑡𝑟𝑙𝑒𝑛(data，这句话就是包头+包体的意思，包头是pack函数打包的二进制数据，内容便是真实数据的长度strlen(data)。&lt;/p&gt;
&lt;p&gt;在内存中，整数一般占用4个字节，所以我们看到，在这段数据中0-4字节表示的是包头，剩余的就是真实的数据。但是server不知道呀，怎么告诉server这一事实呢？&lt;/p&gt;
&lt;p&gt;看配置package_length_offset和package_body_offset，前者就是告诉server，从第几个字节开始是长度，后者就是从第几个字节开始计算长度。&lt;/p&gt;
&lt;p&gt;4、既然如此，我们就可以在onReceive回调对数据解包，然后从包头中取出包体长度，再从接收到的数据中截取真正的包体。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$info = unpack(&#39;N&#39;, $data);
$len = $info[1];
$body = substr($data, - $len);
echo &amp;quot;server received data: {$body}\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;- https://lizcao.github.io/posts/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%AD%A3%E8%A7%A3/ - lizcao copyright.</description>
        </item>
    
    
  </channel>
</rss> 