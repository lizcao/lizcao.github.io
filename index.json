[{"categories":["swoole"],"content":"1、什么是字节序 字节序，顾名思义就是字节的顺序。更具体的讲，它是多字节数据存储和传输时，字节的顺序。 ","date":"2020-06-21","objectID":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/:0:1","tags":["字节序"],"title":"理解字节序","uri":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["swoole"],"content":"2、为什么有“字节序”这个东西 因为物理内存是以字节为单位进行数据存储，也就是我们常说的计算机基本单位为字节。 因此，单字节的数据（如c或java的char类型的数据）没有字节序这一说，因为获取它只需要读取一个字节。而多字节数据，由于有多个字节，所以在存储和传输可以使用不同的顺序进行操作。 ","date":"2020-06-21","objectID":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/:0:2","tags":["字节序"],"title":"理解字节序","uri":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["swoole"],"content":"3、举个例子 十六进制数 0x12345678 共占4个字节，分别是0x12、0x34、0x56、0x78，因此在该数字中0x12属于高位数据，0x78属于地位数据。 注： 可以把内存看成是一个很大的数组，4G内存则是一个长度为4294967296的数组。 该数组的索引其实就是内存地址，左边是比较小的地址，右边则越来越大，直至最大值。 第一种顺序：低地址存放高位数据，叫大端模式 第二种顺序：低地址存放低位数据，叫小端模式 两者，大端模式比较符合人类的阅读习惯；小端模式更符合计算机的处理方式，因为计算机从低位开始处理。 ","date":"2020-06-21","objectID":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/:0:3","tags":["字节序"],"title":"理解字节序","uri":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["swoole"],"content":"4、大小端的应用场景 网络序：也称为网络字节序，都是大端模式。因为TCP/IP协议对各层协议统一规定采用大端模式。 主机序：机器的字节序，有大端模式也有小端模式，根据具体机器的处理决定的，小端模式较常见。 那么，在进行网络通讯时，在将本地数据发送到网络上就需要注意这个顺序。如果本地机器的字节序是小端模式，则需要先转换成大端模式后再进行发送；如果本地已经是大端模式，则可以直接发送。 ps.在私有协议上的数据，只要收发两端约定好，用什么顺序都行。不过，还是建议用网络序发送。 ","date":"2020-06-21","objectID":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/:0:4","tags":["字节序"],"title":"理解字节序","uri":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["swoole"],"content":"5、如何判断主机序 int main() { int x = 0x1020304; char* p = (char*)\u0026x; if(p[0]==1){ printf(\"Big\\n\"); } else{ printf(\"Little\\n\"); } return 0; } ","date":"2020-06-21","objectID":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/:0:5","tags":["字节序"],"title":"理解字节序","uri":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["swoole"],"content":"6、Java设置大小端 public class HelloEndian { public static void main(String[] args) { ByteBuffer b = ByteBuffer.wrap(new byte[4]); b.order(ByteOrder.BIG_ENDIAN); b.putInt(0x01020304); System.out.println(\"Big-Endian: \" + Arrays.toString(b.array())); b = ByteBuffer.wrap(new byte[4]); b.order(ByteOrder.LITTLE_ENDIAN); b.putInt(0x01020304); System.out.println(\"Little-Endian: \" + Arrays.toString(b.array())); } } ","date":"2020-06-21","objectID":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/:0:6","tags":["字节序"],"title":"理解字节序","uri":"/%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E5%BA%8F/"},{"categories":["docker"],"content":"docker创建镜像有两种方式 ","date":"2020-06-20","objectID":"/%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","tags":["docker"],"title":"docker创建镜像有两种方式","uri":"/%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["docker"],"content":"1、dockerfile方式创建 创建dockerfile FROMphp:7.4-cliENV DEBIAN_FRONTEND noninteractiveENV TERM xterm-colorARG DEV_MODEENV DEV_MODE $DEV_MODECOPY ./rootfilesystem/ /RUN \\ curl \\ -sfL \\ --connect-timeout 5 \\ --max-time 15 \\ --retry 5 \\ --retry-delay 2 \\ --retry-max-time 60 \\ http://getcomposer.org/installer | php -- --install-dir=\"/usr/bin\" --filename=composer \u0026\u0026 \\ chmod +x \"/usr/bin/composer\" \u0026\u0026 \\ composer self-update 1.10.6 \u0026\u0026 \\ apt-get update \u0026\u0026 \\ apt-get install -y \\ inotify-tools \\ libssl-dev \\ supervisor \\ unzip \\ zlib1g-dev \\ --no-install-recommends \u0026\u0026 \\ install-swoole.sh master \u0026\u0026 \\ mkdir -p /var/log/supervisor \u0026\u0026 \\ rm -rf /var/lib/apt/lists/* /usr/bin/qemu-*-staticENTRYPOINT [\"/entrypoint.sh\"]CMD []WORKDIR\"/var/www/\" ","date":"2020-06-20","objectID":"/%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:1","tags":["docker"],"title":"docker创建镜像有两种方式","uri":"/%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["docker"],"content":"根据dockerfile生成镜像 执行命令 docker build -t myswool . 具体的参数可以参考 ","date":"2020-06-20","objectID":"/%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:2","tags":["docker"],"title":"docker创建镜像有两种方式","uri":"/%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["docker"],"content":"什么是docker-composer docker-composer是docker推出的，实现多容器编排的工具 ","date":"2020-06-20","objectID":"/docker-composer/:0:1","tags":["docker"],"title":"什么是docker-composer","uri":"/docker-composer/"},{"categories":["docker"],"content":"相对传统的好处 传统的方式，都是我们会每次docker run一些不同的镜像，如下图 //启动nginx docker run --name nginx -p 80:80 nginx //启动mysql docker run --name mysql -p 3306:3306 mysql 如果需要不同的镜像之间，能够通讯，还需要写上link的参数，如下图 //用link参数来实现nginx对php-fpm的访问 docker run --name nginx -p 80:80 --link php-fpm -d nginx 即使是dockerfile的形式，可以在一个容器里面放很多的服务，但是如果想不同的服务容器之间，做分开的管理，还是无法解决问题 所以，docker-composer的方式，就是解决上述的问题的。一次yml文件，即可完成多服务容器的管理 ","date":"2020-06-20","objectID":"/docker-composer/:0:2","tags":["docker"],"title":"什么是docker-composer","uri":"/docker-composer/"},{"categories":["docker"],"content":"docker-composer的基本语法 image ervices: php-fpm: image: 'php:fpm' 说明: image是指定服务的镜像名称或镜像ID tip: 本地不存在，则会做远程拉取 build build: context: ../ dockerfile: path/Dockerfile 说明:构建dockerfile文件 ports services: php-fpm: image: 'php:fpm' //指定端口 ports: - 9000:9000 说明:指定不同的端口。即为本机端口映射服务容器端口 volumes volumes: - ./php/www.conf:/usr/local/etc/php-fpm.d/www.conf 说明:挂载文件 links links: - mysql 说明: 链接其他的服务容器 ","date":"2020-06-20","objectID":"/docker-composer/:0:3","tags":["docker"],"title":"什么是docker-composer","uri":"/docker-composer/"},{"categories":["docker"],"content":"php环境搭建compose文件 version: '2' services: php-fpm: image: 'php:fpm' ports: - 9000:9000 volumes: - ./php/www.conf:/usr/local/etc/php-fpm.d/www.conf - ./php/php.ini:/usr/local/etc/php/php.ini - ./html:/var/www/html links: - mysql networks: - bbc nginx: image: 'nginx' ports: - 80:80 volumes: - ./nginx/default.conf:/etc/nginx/conf.d/default.conf - ./html:/usr/share/nginx/html links: - php-fpm networks: - bbc mysql: image: hub.c.163.com/library/mysql:5.6.36 hostname: mysql ports: - \"127.0.0.1:3306:3306\" volumes: - ./mysql:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=123456 networks: - bbc networks: bbc: driver: bridge 说明: 1.总共有3个服务容器，php,nginx,mysql 2.links做了服务容器的链接 3.networks的bridge为桥接模式，也是为常见的方式。具体详细的，大家可自行搜索 ","date":"2020-06-20","objectID":"/docker-composer/:0:4","tags":["docker"],"title":"什么是docker-composer","uri":"/docker-composer/"},{"categories":["swoole"],"content":"查看最大连接数 clz@V_LZCAO-MB0 http % ulimit -n 256 ","date":"2020-06-20","objectID":"/%E9%AB%98%E6%80%A7%E8%83%BDhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":null,"title":"高性能http服务器","uri":"/%E9%AB%98%E6%80%A7%E8%83%BDhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["php"],"content":" \u003c?php $pid = pcntl_fork(); //父进程和子进程都会执行下面代码 if ($pid == -1) { //错误处理：创建子进程失败时返回-1. die('could not fork'); } else if ($pid) { //父进程会得到子进程号，所以这里是父进程执行的逻辑 pcntl_wait($status); //等待子进程中断，防止子进程成为僵尸进程。 } else { //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。 } 如果一个任务被分解成多个进程执行，就会减少整体的耗时。 比如有一个比较大的数据文件要处理，这个文件由很多行组成。如果单进程执行要处理的任务，量很大时要耗时比较久。这时可以考虑多进程。 有一个1000万个元素的int数组，需要求和，平均分到4个进程处理，每个进程处理一部分，再将结果统计出来，代码如下 \u003c?php $arrint = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];//假设很多 $arrint = array_chunk($arrint,4,TRUE); for ($i = 0; $i \u003c 4; $i++){ $pid = pcntl_fork(); if ($pid == -1) { die(\"could not fork\"); } elseif ($pid) { echo $pid; echo \"I'm the Parent $i\\n\"; } else { // 子进程处理 // $content = file_get_contents(\"prefix_name0\".$i); $psum = array_sum($arrint[$i]); echo $psum . \"\\n\";分别输出子进程的部分求和数字，但是无法进行想加，因为进程互相独立 exit;// 一定要注意退出子进程,否则pcntl_fork() 会被子进程再fork,带来处理上的影响。 } } // 等待子进程执行结 while (pcntl_waitpid(0, $status) != -1) { $status = pcntl_wexitstatus($status); echo \"Child $statuscompleted\\n\"; } 上诉答案中，是把数组分为4个子数组分别用4个子进程去处理了，但是没有办法把所计算的结果相加，因为进程都是独立完成任务的，没有办法共享同一个（内存）变量，下面将引进消息队列来解决进程通信的问题 \u003c?php $arrint = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];//假设很多 $arrint = array_chunk($arrint,4,TRUE);//把数组分为4个 // 创建消息队列,以及定义消息类型(类似于数据库中的库) $id = ftok(__FILE__,'m');//生成文件key，唯一 $msgQueue = msg_get_queue($id); const MSG_TYPE = 1; msg_send($msgQueue,MSG_TYPE,'0');//给消息队列一个默认值0，必须是字符串类型 //fork出四个子进程 for ($i = 0; $i \u003c 4; $i++){ $pid = pcntl_fork(); if ($pid == -1) { die(\"could not fork\"); } elseif ($pid) { echo $pid; echo \"I'm the Parent $i\\n\"; } else { // 子进程处理逻辑，相互独立，解决办法，放到内存消息队列中 $part = array_sum($arrint[$i]); implode_sum($part);//合成计算出的sum exit;// 一定要注意退出子进程,否则pcntl_fork() 会被子进程再fork,带来处理上的影响。 } } function implode_sum($part){ global $msgQueue; msg_receive($msgQueue,MSG_TYPE,$msgType,1024,$sum);//获取消息队列中的值，最后一个参数为队列中的值 $sum = intval($sum) + $part; msg_send($msgQueue,MSG_TYPE,$sum);//发送每次计算的结果给消息队列 } // 等待子进程执行结束 while (pcntl_waitpid(0, $status) != -1) { $status = pcntl_wexitstatus($status); $pid = posix_getpid(); echo \"Child $statuscompleted\\n\"; } //所有子进程结束后，再取出最后在队列中的值，就是int数组的和 msg_receive($msgQueue,MSG_TYPE,$msgType,1024,$sum); echo $sum;//输出120 ","date":"2020-06-17","objectID":"/php%E5%A4%9A%E8%BF%9B%E7%A8%8B/:0:0","tags":["php多进程"],"title":"php多进程","uri":"/php%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"categories":["swoole"],"content":"进程结构图 ","date":"2020-05-27","objectID":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/:0:1","tags":null,"title":"swoole进程模型","uri":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["swoole"],"content":"Reactor 线程 Reactor 线程是在 Master 进程中创建的线程 负责维护客户端 TCP 连接、处理网络 IO、处理协议、收发数据 不执行任何 PHP 代码 将 TCP 客户端发来的数据缓冲、拼接、拆分成完整的一个请求数据包 ","date":"2020-05-27","objectID":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/:0:2","tags":null,"title":"swoole进程模型","uri":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["swoole"],"content":"Worker 进程 接受由 Reactor 线程投递的请求数据包，并执行 PHP 回调函数处理数据 生成响应数据并发给 Reactor 线程，由 Reactor 线程发送给 TCP 客户端 可以是异步非阻塞模式，也可以是同步阻塞模式 Worker 以多进程的方式运行 ","date":"2020-05-27","objectID":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/:0:3","tags":null,"title":"swoole进程模型","uri":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["swoole"],"content":"TaskWorker 进程 接受由 Worker 进程通过 Swoole\\Server-\u003etask/taskwait/taskCo/taskWaitMulti 方法投递的任务 处理任务，并将结果数据返回（使用 Swoole\\Server-\u003efinish给 Worker 进程 完全是同步阻塞模式 TaskWorker 以多进程的方式运行，task 完整示例 ","date":"2020-05-27","objectID":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/:0:4","tags":null,"title":"swoole进程模型","uri":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["swoole"],"content":"Manager 进程 负责创建 / 回收 worker/task 进程 他们之间的关系可以理解为 Reactor 就是 nginx，Worker 就是 PHP-FPM。Reactor 线程异步并行地处理网络请求，然后再转发给 Worker 进程中去处理。Reactor 和 Worker 间通过 unixSocket 进行通信。 在 PHP-FPM 的应用中，经常会将一个任务异步投递到 Redis 等队列中，并在后台启动一些 PHP 进程异步地处理这些任务。Swoole 提供的 TaskWorker 是一套更完整的方案，将任务的投递、队列、PHP 任务处理进程管理合为一体。通过底层提供的 API 可以非常简单地实现异步任务的处理。另外 TaskWorker 还可以在任务执行完成后，再返回一个结果反馈到 Worker。 Swoole 的 Reactor、Worker、TaskWorker 之间可以紧密的结合起来，提供更高级的使用方式。 一个更通俗的比喻，假设 Server 就是一个工厂，那 Reactor 就是销售，接受客户订单。而 Worker 就是工人，当销售接到订单后，Worker 去工作生产出客户要的东西。而 TaskWorker 可以理解为行政人员，可以帮助 Worker 干些杂事，让 Worker 专心工作。 如图： ","date":"2020-05-27","objectID":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/:0:5","tags":null,"title":"swoole进程模型","uri":"/swoole%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"categories":["压测"],"content":"1、安装influxdb docker search influx docker pull influxdb docker run --name my_influ -p 8086:8086 influxdb docker exec -it my_influ /bin/bash 创建数据库 influx create database jmeter show databases exit ","date":"2020-05-25","objectID":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/:0:1","tags":null,"title":"jmeter+grafana+influxdb可视化性能监控平台","uri":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"},{"categories":["压测"],"content":"2、安装grafana docker search grafana docker pull grafana/grafana docker run --name my_grafana -p 3000:3000 grafana/grafana 进入容器也可以通过docker的k8s进入 ","date":"2020-05-25","objectID":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/:0:2","tags":null,"title":"jmeter+grafana+influxdb可视化性能监控平台","uri":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"},{"categories":["压测"],"content":"3、配置 避坑提示 访问使用内网私有地址如本机的192.168.31.209，不要使用127.0.0.1，不然有坑 访问grafana http://192.168.31.209:3000/，登录admin/admin 添加数据源 即刚才创建的数据库 配置如下 展示模板 https://grafana.com/grafana/dashboards/5496 下载对应的json文件，导入到grafana 导入成功后可以看到对应的界面。 ","date":"2020-05-25","objectID":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/:0:3","tags":null,"title":"jmeter+grafana+influxdb可视化性能监控平台","uri":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"},{"categories":["压测"],"content":"4、jemeter配置 安装与启动 略 线程组配置 后端监听器配置 ","date":"2020-05-25","objectID":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/:0:4","tags":null,"title":"jmeter+grafana+influxdb可视化性能监控平台","uri":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"},{"categories":["压测"],"content":"5、开始压测 点击jemeter启动按钮开始压测 ","date":"2020-05-25","objectID":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/:0:5","tags":null,"title":"jmeter+grafana+influxdb可视化性能监控平台","uri":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"},{"categories":["压测"],"content":"6、测试结果 ","date":"2020-05-25","objectID":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/:0:6","tags":null,"title":"jmeter+grafana+influxdb可视化性能监控平台","uri":"/docker%E4%B8%8B%E6%90%AD%E5%BB%BAjmeter-grafana-influxdb%E5%8F%AF%E8%A7%86%E5%8C%96%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"},{"categories":["php"],"content":"PHP-FPM 的运作模式 PHP-FPM是一个多进程的 FastCGI 管理程序，是绝大多数 PHP应用所使用的运行模式。 假设我们使用 Nginx 提供 HTTP 服务（Apache 同理），所有客户端发起的请求最先抵达的都是 Nginx，然后 Nginx 通过 FastCGI 协议将请求转发给 PHP-FPM 处理，PHP-FPM 的 Worker 进程 会抢占式的获得 CGI 请求进行处理，这个处理指的就是，等待 PHP 脚本的解析，等待业务处理的结果返回，完成后回收子进程，这整个的过程是阻塞等待的，也就意味着 PHP-FPM 的进程数有多少能处理的请求也就是多少，假设 PHP-FPM 有 200 个 Worker 进程，一个请求将耗费 1 秒的时间，那么简单的来说整个服务器理论上最多可以处理的请求也就是 200 个，QPS 即为 200/s，在高并发的场景下，这样的性能往往是不够的，尽管可以利用 Nginx 作为负载均衡配合多台 PHP-FPM 服务器来提供服务，但由于 PHP-FPM 的阻塞等待的工作模型，一个请求会占用至少一个 MySQL 连接，多节点高并发下会产生大量的 MySQL 连接，而 MySQL 的最大连接数默认值为 100，尽管可以修改，但显而易见该模式没法很好的应对高并发的场景。 PHP-FPM 即 PHP FastCGI 进程管理器，要了解 PHP-FPM ，首先要看看 CGI 与 FastCGI 的关系。 ","date":"2020-05-25","objectID":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/:0:1","tags":["php多进程"],"title":"php-fpm运作原理","uri":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["php"],"content":"CGI CGI 的英文全名是 Common Gateway Interface，即通用网关接口，是 Web 服务器调用外部程序时所使用的一种服务端应用的规范。 早期的 Web 通信只是按照客户端请求将保存在 Web 服务器硬盘中的数据转发过去而已，这种情况下客户端每次获取的信息也是同样的内容（即静态请求，比如图片、样式文件、HTML文档），而随着 Web 的发展，Web 所能呈现的内容更加丰富，与用户的交互日益频繁，比如博客、论坛、电商网站、社交网络等。 这个时候仅仅通过静态资源已经无法满足 Web 通信的需求，所以引入 CGI 以便客户端请求能够触发 Web 服务器运行另一个外部程序，客户端所输入的数据也会传给这个外部程序，该程序运行结束后会将生成的 HTML 和其他数据通过 Web 服务器再返回给客户端（即动态请求，比如基于 PHP、Python、Java 实现的应用）。利用 CGI 可以针对用户请求动态返回给客户端各种各样动态变化的信息。 ","date":"2020-05-25","objectID":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/:0:2","tags":["php多进程"],"title":"php-fpm运作原理","uri":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["php"],"content":"FastCGI FastCGI 顾名思义，是 CGI 的升级版本，为了提升 CGI 的性能而生，CGI 针对每个 HTTP 请求都会 fork 一个新进程来进行处理（解析配置文件、初始化执行环境、处理请求），然后把这个进程处理完的结果通过 Web 服务器转发给用户，刚刚 fork 的新进程也随之退出，如果下次用户再请求动态资源，那么 Web 服务器又再次 fork 一个新进程，如此周而复始循环往复。 而 FastCGI 则会先 fork 一个 master 进程，解析配置文件，初始化执行环境，然后再 fork 多个 worker 进程（与 Nginx 有点像），当 HTTP 请求过来时，master 进程将其会传递给一个 worker 进程，然后立即可以接受下一个请求，这样就避免了重复的初始化操作，效率自然也就提高了。 而且当 worker 进程不够用时，master 进程还可以根据配置预先启动几个 worker 进程等着； 当空闲 worker 进程太多时，也会关掉一些，这样不仅提高了性能，还节约了系统资源。 ","date":"2020-05-25","objectID":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/:0:3","tags":["php多进程"],"title":"php-fpm运作原理","uri":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["php"],"content":"PHP-FPM FastCGI 只是一个协议规范，需要每个语言具体去实现，PHP-FPM 就是 PHP 版本的 FastCGI 协议实现。 master进程只有一个，负责监听端口，接收来自服务器的请求，而worker进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP解释器， 是PHP代码真正执行的地方，比如：1个master进程，2个worker进程。 从FPM接收到请求，到处理完毕，其具体的流程如下 FPM的master进程接收到请求。 master进程根据配置指派特定的worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合Nginx遇到502错误比较多的原因。 worker进程处理请求，如果超时，返回504错误。 请求处理结束，返回结果。 ","date":"2020-05-25","objectID":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/:0:4","tags":["php多进程"],"title":"php-fpm运作原理","uri":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["php"],"content":"PHP-FPM配置文件 pid = run/php-fpm.pid #pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启 error_log = log/php-fpm.log #错误日志，默认在安装目录中的var/log/php-fpm.log log_level = notice #错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice. emergency_restart_threshold = 60 emergency_restart_interval = 60s #表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。 process_control_timeout = 0 #设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0. daemonize = yes #后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。 listen = 127.0.0.1:9000 #fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置. listen.backlog = -1 #backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。 listen.allowed_clients = 127.0.0.1 #允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接 listen.owner = www listen.group = www listen.mode = 0666 #unix socket设置选项，如果使用tcp方式访问，这里注释即可。 user = www group = www #启动进程的帐户和组 pm = dynamic #对于专用服务器，pm可以设置为static。 #如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定： pm.max_children #，子进程最大数 pm.start_servers #，启动时的进程数 pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程 pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理 pm.max_requests = 1000 #设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ’0′ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0. pm.status_path = /status #FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到 ping.path = /ping #FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。 ping.response = pong #用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong. request_terminate_timeout = 0 #设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ’0′ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。 request_slowlog_timeout = 10s #当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ’0′ 表示 ‘Off’ slowlog = log/$pool.log.slow #慢请求的记录日志,配合request_slowlog_timeout使用 rlimit_files = 1024 #设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。 rlimit_core = 0 #设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值. chroot = #启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用. chdir = #设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时） catch_workers_output = yes #重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空. ","date":"2020-05-25","objectID":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/:0:5","tags":["php多进程"],"title":"php-fpm运作原理","uri":"/php-fpm%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["php"],"content":"变量容器 每个php变量存在一个叫”zval”的变量容器中。 一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。 is_ref 第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。 第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。 通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用\u0026来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。 refcount 第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 ","date":"2020-05-25","objectID":"/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:0:1","tags":null,"title":"PHP引用计数","uri":"/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"categories":["php"],"content":"标量类型 当一个变量被赋常量值时，就会生成一个zval变量容器，如下例这样： \u003c?php $a = \"new string\"; 在上例中，新的变量a，是在当前作用域中生成的。并且生成了类型为 string和值为new string的变量容器。 在额外的两个字节信息中，”is_ref”被默认设置为 FALSE ，因为没有任何自定义的引用生成。”refcount” 被设定为 1，因为这里只有一个变量使用这个变量容器. 注意到当”refcount”的值是1时，”is_ref”的值总是 FALSE . 如果你已经安装了» Xdebug，你能通过调用函数 xdebug_debug_zval() 显示”refcount”和”is_ref”的值。 \u003c?php xdebug_debug_zval ( 'a' ); 以上例程会输出： a: (refcount=1, is_ref=0)='new string' 把一个变量赋值给另一变量将增加引用次数(refcount) \u003c?php $a = \"new string\" ; $b = $a ; xdebug_debug_zval ( 'a' ); 以上例程会输出： a: (refcount=2, is_ref=0)='new string' 这时，引用次数是2，因为同一个变量容器被变量 a 和变量 b 关联。 当没必要时，php不会去复制已生成的变量容器。 变量容器在”refcount“变成0时就被销毁。 当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数 unset() 时，”refcount“就会减1，下面的例子就能说明: \u003c?php $a = \"new string\" ; $c = $b = $a ; xdebug_debug_zval ( 'a' ); unset( $b , $c ); xdebug_debug_zval ( 'a' ); 以上例程会输出： a: (refcount=3, is_ref=0)='new string' a: (refcount=1, is_ref=0)='new string' 如果我们现在执行 unset($a);，包含类型和值的这个变量容器就会从内存中删除。 ","date":"2020-05-25","objectID":"/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:0:2","tags":null,"title":"PHP引用计数","uri":"/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"categories":["php"],"content":"复合类型 当考虑像 array 和 object 这样的复合类型时，事情就稍微有点复杂. 与 标量(scalar) 类型的值不同， array 和 object 类型的变量把它们的成员或属性存在自己的符号表中。这意味着下面的例子将生成三个zval变量容器。 \u003c?php $a = array( 'meaning' =\u003e 'life' , 'number' =\u003e 42 ); xdebug_debug_zval ( 'a' ); 以上例程的输出类似于： a: (refcount=1, is_ref=0)=array ( 'meaning' =\u003e (refcount=1, is_ref=0)='life', 'number' =\u003e (refcount=1, is_ref=0)=42 ) 这三个zval变量容器是: a ， meaning 和 number 。增加和减少”refcount”的规则和上面提到的一样. 下面, 我们在数组中再添加一个元素,并且把它的值设为数组中已存在元素的值: \u003c?php $a = array( 'meaning' =\u003e 'life' , 'number' =\u003e 42 ); $a['life'] = $a['meaning']; xdebug_debug_zval ( 'a' ); 以上例程的输出类似于： a: (refcount=1, is_ref=0)=array ( 'meaning' =\u003e (refcount=2, is_ref=0)='life', 'number' =\u003e (refcount=1, is_ref=0)=42, 'life' =\u003e (refcount=2, is_ref=0)='life' ) 从以上的xdebug输出信息，我们看到原有的数组元素和新添加的数组元素关联到同一个”refcount”2的zval变量容器. 尽管 Xdebug的输出显示两个值为*‘life’*的 zval 变量容器，其实是同一个。 函数 **xdebug_debug_zval()** 不显示这个信息，但是你能通过显示内存指针信息来看到。 删除数组中的一个元素，就是类似于从作用域中删除一个变量. 删除后,数组中的这个元素所在的容器的“refcount”值减少，同样，当“refcount”为0时，这个变量容器就从内存中被删除，下面又一个例子可以说明： \u003c?php $a = array( 'meaning' =\u003e 'life', 'number' =\u003e 42 ); ） $a['life'] = $a['meaning']; unset( $a['meaning'], $a['number']); xdebug_debug_zval('a'); 以上例程的输出类似于： a: (refcount=1, is_ref=0)=array ( 'life' =\u003e (refcount=1, is_ref=0)='life' ) 现在，当我们添加一个数组本身作为这个数组的元素时，事情就变得有趣，下个例子将说明这个。例中我们加入了引用操作符，否则php将生成一个复制。 \u003c?php $a = array( 'one' ); $a [] =\u0026 $a ; xdebug_debug_zval ( 'a' ); 以上例程的输出类似于： a: (refcount=2, is_ref=1)=array ( 0 =\u003e (refcount=1, is_ref=0)='one', 1 =\u003e (refcount=2, is_ref=1)=... ) 能看到数组变量 ( a ) 同时也是这个数组的第二个元素( 1 ) 指向的变量容器中“refcount”为 2。上面的输出结果中的”…”说明发生了递归操作, 显然在这种情况下意味着”…”指向原始数组。跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量 $a 调用unset, 那么变量 $a 和数组元素 “1” 所指向的变量容器的引用次数减1, 从”2″变成”1″. 下例可以说明: (refcount=1, is_ref=1)=array ( 0 =\u003e (refcount=1, is_ref=0)='one', 1 =\u003e (refcount=1, is_ref=1)=... ) ","date":"2020-05-25","objectID":"/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:0:3","tags":null,"title":"PHP引用计数","uri":"/php%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"categories":["swoole"],"content":" 自知之明是最难得的知识。 ","date":"2020-05-25","objectID":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"swoole粘包问题","uri":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["swoole"],"content":"TCP传输的特点 TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议 面向连接 面向连接意味着使用tcp的应用程序在传输数据前必须先建立连接，三次握手 基于字节流的传输 发送端执行的写操作数和接收端执行的读操作次数之间没有任何数量关系，当发送端应用程序连续执行多次写操作的时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据的时候，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出 可靠 TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功。 TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。 ","date":"2020-05-25","objectID":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/:0:1","tags":null,"title":"swoole粘包问题","uri":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["swoole"],"content":"什么是TCP粘包问题 TCP粘包是一个错误的说法，TCP是流式传输，没有包的概念，更没有粘包一说。 人们常说的粘包问题，是指发送方应该以什么格式发送数据，接收方能正确解析出数据，这个叫应用层协议，你自己定，跟TCP完全无关。如果是发文件，最简单的你可以用http协议封装，如果你发的http协议数据是100%正确的，无论哪个接收方（nginx/tomcat/iis）保证能一字节不差地收下，因为http协议本身就带header和body，header里有Content-Length: 12345指定了body的大小，body才是文件本身。 你不用http协议，直接发文件数据，那么问题来了，接收方怎么知道应该收多少字节后文件结束？这个才是真正粘包问题的由来。 所有TCP粘包问题就转化成了如何界定TCP流式传输边界的问题。 ","date":"2020-05-25","objectID":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/:0:2","tags":null,"title":"swoole粘包问题","uri":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["swoole"],"content":"TCP粘包的原因 缓冲区 通常我们直觉性的认为，客户端直接向网络中传输数据，对端从网络中读取数据，但是这是不正确的。 socket有缓冲区buffer的概念，每个TCP socket在内核中都有一个发送缓冲区和一个接收缓冲区。客户端send操作仅仅是把数据拷贝到buffer中，也就是说send完成了，数据并不代表已经发送到服务端了，之后才由TCP协议从buffer中发送到服务端。此时服务端的接收缓冲区被TCP缓存网络上来的数据，而后server才从buffer中读取数据。 当连续发送数据时，由于tcp协议的nagle算法，会将较小的内容拼接成大的内容，一次性发送到服务器端，因此造成粘包 当发送内容较大时，由于服务器端的recv（buffer_size）方法中的buffer_size较小，不能一次性完全接收全部内容，因此在下一次请求到达时，接收的内容依然是上一次没有完全接收完的内容，因此造成粘包现象。 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 粘包、拆包表现形式 第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。 第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。 第三种情况，这种情况有两种表现形式。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。 ","date":"2020-05-25","objectID":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/:0:3","tags":null,"title":"swoole粘包问题","uri":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["swoole"],"content":"TCP粘包的解决方法 EOF 结束符协议 固定包头 + 包体协议 粘包复现 创建一个server，server端代码如下 \u003c?php class TcpBufferServer { private $_serv; /** * init */ public function __construct() { $this-\u003e_serv = new Swoole\\Server(\"127.0.0.1\", 9501); $this-\u003e_serv-\u003eset([ 'worker_num' =\u003e 1, ]); $this-\u003e_serv-\u003eon('Receive', [$this, 'onReceive']); } public function onReceive($serv, $fd, $fromId, $data) { echo \"Server received data: {$data}\" . PHP_EOL; } /** * start server */ public function start() { $this-\u003e_serv-\u003estart(); } } $reload = new TcpBufferServer; $reload-\u003estart(); server的代码很简单，仅仅是在收到客户端代码后，标准输出一句话而已，client的代码需要注意了，我们写了一个for循环，连续向server send三条信息，代码如下 \u003c?php $client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC); $client-\u003econnect('127.0.0.1', 9501) || exit(\"connect failed. Error: {$client-\u003eerrCode}\\n\"); // 向服务端发送数据 for ($i = 0; $i \u003c 3; $i++) { $client-\u003esend(\"Just a test.\\n\"); } $client-\u003eclose(); 在未运行测试的情况下，我们期望server所在终端输出的结果应该是这样的 \u003c?php Server received data: Just a test. Server received data: Just a test. Server received data: Just a test. 注意哦，我们期望的结果是server被回调了3次，才有上述期望的结果值 实际运行的结果呢，是否与我们所期望的一致？我们看下 上图左边是server输出的信息。 我们看到，左侧显示的结果是server一次性输出的结果，按理论来说，client发起了3次请求，server应该跟我们期望的结果一致，会执行3次呀，但是事实并不是，这就产生了粘包，看下抓包的结果。 由抓包的图可见，三次请求的内容到了缓冲区后，作为两次发送，有两个数据发生了粘包，到了服务端缓冲区后，是三个一起取出产生了粘包。 EOF结束协议 EOF，end of file，意思是我们在每一个数据包的结尾加一个eof标记，表示这就是一个完整的数据包，但是如果你的数据本身含有EOF标记，那就会造成收到的数据包不完整，所以开启EOF支持后，应避免数据中含有EOF标记。 在swoole_server中，我们可以配置open_eof_check为true，打开EOF检测，配置package_eof来指定EOF标记。 swoole_server收到一个数据包时，会检测数据包的结尾是否是我们设置的EOF标记，如果不是就会一直拼接数据包，直到超出buffer或者超时才会终止，一旦认定是一个完整的数据包，就会投递给Worker进程，这时候我们才可以在回调内处理数据。 这样server就能保证接收到一个完整的数据包了？不能保证，这样只能保证server能收到一个或者多个完整的数据包。 为啥是多个呢？ 我们说了开启EOF检测，即open_eof_check设置为true，server只会检测数据包的末尾是否有EOF标记，如果向我们开篇的案例连发3个EOF的数据，server可能还是会一次性收到，这样我们只能在回调内对数据包进行拆分处理。 我们拿开篇的案例为例 server开启eof检测并指定eof标记是\\r\\n，代码如下 \u003c?php class TcpBufferServer { private $_serv; /** * init */ public function __construct() { $this-\u003e_serv = new Swoole\\Server(\"127.0.0.1\", 9501); /* $this-\u003e_serv-\u003eset([ 'worker_num' =\u003e 1, ]);*/ $this-\u003e_serv-\u003eset([ 'worker_num' =\u003e 1, 'open_eof_check' =\u003e true, //打开EOF检测 'package_eof' =\u003e \"\\r\\n\", //设置EOF ]); $this-\u003e_serv-\u003eon('Receive', [$this, 'onReceive']); } public function onReceive($serv, $fd, $fromId, $data) { echo \"Server received data: {$data}\" . PHP_EOL; } /** * start server */ public function start() { $this-\u003e_serv-\u003estart(); } } $reload = new TcpBufferServer; $reload-\u003estart(); 客户端设置发送的数据末尾是\\r\\n符号，代码如下 \u003c?php $client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC); $client-\u003econnect('127.0.0.1', 9501) || exit(\"connect failed. Error: {$client-\u003eerrCode}\\n\"); // 向服务端发送数据 /*for ($i = 0; $i \u003c 3; $i++) { $client-\u003esend(\"Just a test.\\n\"); }*/ for ($i = 0; $i \u003c 3; $i++) { $client-\u003esend(\"Just a test.\\r\\n\"); } $client-\u003eclose(); 按照我们刚才的分析，server的效果可能会一次性收到多个完整的包，我们运行看看结果 明显不是我们想要的结果，抓包的结果与上面是一样的。 原来我们还需要在onReceive回调内对收到的数据进行拆分处理 \u003c?php public function onReceive($serv, $fd, $fromId, $data) { // echo \"Server received data: {$data}\" . PHP_EOL; $datas = explode(\"\\r\\n\", $data); foreach ($datas as $data) { if(!$data) continue; echo \"Server received data: {$data}\" . PHP_EOL; } } 此时我们再看下运行结果 自行分包的效果便实现了，考虑到自行分包稍微麻烦，swoole提供了open_eof_split配置参数，启用该参数后，server会从左到右对数据进行逐字节对比，查找数据中的EOF标记进行分包，效果跟我们刚刚自行拆包是一样的，性能较差。 在案例的基础上我们看看open_eof_split配置 \u003c?php $this-\u003e_serv-\u003eset([ 'worker_num' =\u003e 1, 'open_eof_check' =\u003e true, //打开EOF检测 'package_eof' =\u003e \"\\r\\n\", //设置EOF 'open_eof_split' =\u003e true, ]); onReceive的回调，我们不需要自行拆包 \u003c?php public function onReceive($serv, $fd, $fromId, $data) { echo \"Server received data: {$data}\" . PHP_EOL; } client的测试代码使用\\r\\n（同server端package_eof标记一致），我们看下运行效果 EOF标记解决粘包就说这么多，下面我们再看看另一种解决方案 固定包头+包体协议 固定包头是一种非常通用的协议，它的含义就是在你要发送的数据包的前面，添加一段信息，这段信息了包含了你要发送的数据包的长度，长度一般是2个或者4个字节的整数。 在这种协议下，我们的数据包的组成就是包头+包体。其中包头就是包体长度的二进制形式。比如我们本来想向服务端发送一段数据 “Just a test.” 共12个字符，现在我们要发送的数据就应该是这样的 \u003c?php pack('N', strlen(\"Just a test.\")) . \"Just a test.\" 其中php的pack函数是把数据打包成二进制字符串。 为什么这样就能保证Worker进程收到的是一个完整的数据包呢？我来解释一下： 当server收到一个数据包（可能是多个完整的数据包）之后，会先解出包头指定的数据长度，然后按照这个长度取出后面的数据，如果一次性收到","date":"2020-05-25","objectID":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/:0:4","tags":null,"title":"swoole粘包问题","uri":"/swoole%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["tcp"],"content":" 人，只要有一种信念，有所追求，什么艰苦都能忍受，什么环境也都能适应。——丁玲 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:0","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"三次握手流程图 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:1","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"四次挥手流程图 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:2","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"tcp报文 其中，Seq(Sequence Number) 是 32 位的序列号，Acknowledgment number 称之为确认序号，也是 32 位的，但是他不是标志位 ACK，这个要区别开，当 ACK 置 1 时 Acknowledgment number 才有效，指接收方期待的下一个报文段的序列号。 TCP 报头信息中有六个控制位(标志位)，分别是：SYN、ACK、PSH、FIN、RST 和 URG。 SYN: 表示建立连接 FIN: 表示关闭连接 ACK: 表示响应 PSH: 表示有数据传输 RST: 表示连接重置 URG: 表示紧急数据 Seq 序列号有两个作用： 第一，在 SYN 置 1 时，此为当前连接的初始序列号(Initial Sequence Number, ISN)该值是个随机值，数据的第一个字节序号为此 ISN+1。 第二，在 SYN 置 0 时，为当前连接报文段的累计数据包字节数。 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:3","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"网络模型 计算机网络分层模型主要有OSI七层模型，TCP/IP五层模型，也有一种四层模型，四层模型会把网卡层和物理层统称为网络接口层。 OSI七层模型存在于教科书了，TCP/IP五层模型是日常运用最为广泛的一种网络架构模型。在学习网络知识时也要把握住重点去学，七层模型了解即可。 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:4","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"代码准备 server.php \u003c?php //创建Server对象，监听 127.0.0.1:9501端口 $serv = new Swoole\\Server(\"127.0.0.1\", 9501); //监听连接进入事件 $serv-\u003eon('Connect', function ($serv, $fd) { echo \"Client: Connect.\\n\"; }); //监听数据接收事件 $serv-\u003eon('Receive', function ($serv, $fd, $from_id, $data) { $serv-\u003esend($fd, \"Server: \".$data); }); //监听连接关闭事件 $serv-\u003eon('Close', function ($serv, $fd) { echo \"Client: Close.\\n\"; }); //启动服务器 $serv-\u003estart(); client.php \u003c?php //client.php $client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC); $client-\u003econnect('127.0.0.1', 9501) || exit(\"connect failed. Error: {$client-\u003eerrCode}\\n\"); // 向服务端发送数据 $client-\u003esend(\"Just a test.\\r\\n\"); $client-\u003eclose(); ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:5","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"wireshark准备 抓包网络选择lookback 筛选条件输入ip.addr == 127.0.0.1 and tcp.port in {9501} ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:6","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"Tcp请求 直接请求client.php php client.php ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:7","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"抓包 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:8","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"模型分析 上面模型网络里有五层，这里只有四层，是因为我直接请求的tcp，没有走应用层，所以只有四层。 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:9","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"三次握手抓包分析 看到wireshark已经抓到了请求 第一次握手 客户端向服务器发送连接请求包，标志位SYN=1，序列号Seq=0（为方便下面的计算用这里的Seq起名为X），如下图 第二次握手 服务器收到客户端发过来报文，由SYN=1知道客户端要求建立联机。向客户端发送一个SYN和ACK都为1的TCP报文，设置初始序号Seq=0（为方便下面的计算用这里的Seq起名为Y），将确认序号(Acknowledgement Number)设置为客户的序列号加1，即X+1=0+1=1，所以这里的序列号为1, 如下图 第三次握手 客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次发送的序号加1（X+1=1）。以及标志位ACK是否为1。若正确，客户端再次发送确认包，ACK标志位为1，SYN标志位为0。确认序号(Acknowledgement Number)=Y+1=0+1=1，发送序号为X+1=1。服务端收到后确认序号值与ACK=1则连接建立成功，可以传送数据了。 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:10","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":["tcp"],"content":"四次挥手抓包分析 第一次挥手 客户端给服务器发送TCP包，用来关闭客户端到服务器的数据传送。将标志位FIN和ACK置为1，序号为X=15，确认序号为Z=1。 第二次挥手 服务器收到FIN后，发回一个ACK(标志位ACK=1),确认序号为收到的序号加1，即X=X+1=16。序号为收到的确认序号=Z。 第三次挥手 服务器关闭与客户端的连接，发送一个FIN。标志位FIN和ACK置为1，序号为Y=1，确认序号为X=16。 第四次握手 客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认序号为收到的序号加1，即Y+1=2。序号为收到的确认序号X=16。 ","date":"2020-05-24","objectID":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/:0:11","tags":null,"title":"tcp三次握手和四次挥手","uri":"/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]